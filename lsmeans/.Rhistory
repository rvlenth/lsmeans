aug(); aug(); aug(); aug(); system.time(print(vcovAdj(BOats.lmer)))
fix(aug)
aug(); aug(); aug(); aug(); system.time(print(vcovAdj(BOats.lmer)))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
nrow(BOats)
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
class(BOats.lmer)
str(BOats.lmer)
summary(BOats.lmer)
q("no")
setwd("h:/scratch")
data=read.csv("alligator.csv")
head(data)
library(nnet)
fit=multinom(food~lake+sex+size, data = data)
library(effects)
I now wanted to get pairiwise Tukey posthoc tests between the different lakes using
library(lsmeans)
x=lsmeans(fit, pairwise~lake, adjust="tukey",mode = "prob") x or summary(lsmeans(fit, pairwise~lake, adjust="tukey",mode = "latent"),type="response")
x=lsmeans(fit, pairwise~lake, adjust="tukey",mode = "prob")
x
sessionInfo()
x@misc
x[[1]]@misc
ls()
vcov(fit)
diag(vcov(fit))
x@V
x[[2]]@V
diag(x[[2]]@V)
lsmeans(fit, "lake")
lsmeans(fit, "lake")@V
lsm = lsmeans(fit, "lake")
lsm@linfct %*% lsm@V %*% t(lsm@linfct)
sqrt(diag(.Last.value))
lsm
vcov(lsm)
lsmeans(fit, "sex")
lsmeans(fit, "size")
lsmeans(fit, "food")
lsmeans(fit, "lake", mode = "prop")
lsmeans(fit, "lake", mode = "prob")
lsmeans(fit, ~ response | lake, mode = "prob")
ref.grid(fit, mode = "prob")
ls()
data
with(data, table(sex, lake, size))
with(data, table(sex))
with(data, table(size))
with(data, table(lake))
summary(fit)
class(fit)
ref.grid(fit)
ref.grid(fit, mode = "latent")
lsmeans(fit, "lake, mode = "latent)
lsmeans(fit, "lake", mode = "latent")
lsmeans(fit, c("lake", "sex"), mode = "latent")
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
library(lsmeans)
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
pat
coef(fit)
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
X
lsmeans(fit, c("lake"), mode = "latent")@linfct
?multinom
pat
lsmeans(fit, c("lake"), mode = "latent")@linfct
lsmeans(fit, c("lake"), mode = "latent")@linfct
pat
pat = pat + .2
pat
library(lsmeans)
lsmeans(fit, c("lake"), mode = "latent")@linfct
pat
lsmeans(fit, c("lake"), mode = "latent")
lsmeans(fit, c("food"))
lsmeans(fit, c("lake"))
lsmeans(fit, c("lake"), mode="latent")
lsmeans(fit, ~ food | lake)
lsmeans(fit, ~ food | lake, mode = "latent")
library(lsmeans)
lsmeans(fit, ~ lake)
lsm.basis.multinom = function(object, trms, xlev, grid,
mode = c("prob", "latent"), ...) {
mode = match.arg(mode)
bhat = t(coef(object))
V = .my.vcov(object, ...)
k = ncol(bhat)
m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
X = model.matrix(trms, m, contrasts.arg = object$contrasts)
# recenter for latent predictions THIS IS WRONG
pat = (rbind(0, diag(k + 1, k)) - 1) / (k + 1)
# Should not recenter... following is right
# pat = rbind(0, diag(1, k)) # not centered
X = kronecker(pat, X)
nbasis = estimability::all.estble
nbasis = kronecker(rep(1,k), nbasis)
misc = list(tran = "log", inv.lbl = "e^y")
dfargs = list(df = object$edf)
dffun = function(k, dfargs) dfargs$df
ylevs = list(class = object$lev)
if (is.null(ylevs)) ylevs = list(class = seq_len(k))
names(ylevs) = as.character(object$call$formula[[2]])
misc$ylevs = ylevs
if (mode == "prob")
misc$postGridHook = .multinom.postGrid
list(X = X, bhat = as.numeric(bhat), nbasis = nbasis, V = V,
dffun = dffun, dfargs = dfargs, misc = misc)
}
fix(lsm.basis.multinom)
lsmeans(fit, ~ lake)
lsmeans(fit, ~ food | lake)
ls()
lsm.basis.newmult = lsm.basis.multinom
class(fit) = c("newmult", class(multinom))
lsmeans(fit, ~ lake)
recover.data.newmult = lsmeans:::recover.data.multinom
lsmeans(fit, ~ lake)
coef(fit)
class(fit)
class(fit) = c("newmult", "multinom", "nnet")
lsmeans(fit, ~ lake)
fix(lsm.basis.newmult)
lsmeans(fit, ~ lake)
lsm.basis.newmult
lsmeans(fit, ~ lake)
lsmeans(fit, ~ lake, type = "response")
with(data, table(lake))
X = with(data, table(lake, sex, size, food))
X
X = with(data, table(sex, size, food, lake))
XX = matrix(X, ncol=4)
XX
apply(XX, 2, mean)
apply(XX, 2, function(x) exp(mean(log(x+1))) - 1)
apply(XX, 2, function(x) exp(mean(log(x+.1))))
X
q("no")
install.packages("pscl")
library(pscl)
example(zeroinfl)
ls()
summary(fm_zip)
summary(fm_zip2)
summary(bioChemists)
new = with(bioChemists, expand.grid(fem=levels(fem),mar=levels(mar), kid5=mean(kid5),phd=mean(phd),ment=mean(ment)))
new
predict(fm_zip, new=new)
?predict.zeroinfl
predict(fm_zip, new=new,type="r")
predict(fm_zip, new=new,type="p")
predict(fm_zip, new=new,type="r")
predict(fm_zip, new=new,type="c")
predict(fm_zip, new=new,type="z")
(1- 0.1569167)*predict(fm_zip,new=new,type="c")
p=predict(fm_zip2, new=new,type="z")
predict(fm_zip2, new=new,type="c")
(1-p)*.Last.value
predict(fm_zip2, new=new,type="r")
p
model.matrix(fm_zip, model="count", frame=new)
?model.matrix
model.matrix(fm_zip, model="count", data=new)
model.matrix(fm_zip, data=new)
lsmeans:::lsm.basis.lm
terms(fm_zip)
names(fm_zip)
fm_zip$terms
fm_zip$terms$zero
model.matrix(terms(fm_zip, "zero"), data=new)
model.matrix(terms(fm_zip, "count"), data=new)
model.matrix(delete.response(terms(fm_zip, "count")), data=new)
model.matrix(terms(fm_zip2, "zero"), data=new)
coef(fm_zip)
coef(fm_zip2)
coef(fm_zip2,"count")
coef(fm_zip2,"zero")
coef(fm_zip2,"both")
coef(fm_zip2,"full")
fm_zip$coefficients
q("no")
library(pscl)
library(lsmeans)
example(hurdle)
ls()
tst = function(object, mode = c("mean","count","zero","prob.ratio")) {
mode = match.arg()
type = switch(mode,
mean = "response", count = "count", prob.ratio = "zero")
rg = ref.grid(object, mode = mode)
cat("predict results:\n ")
print(predict(object, new = rg@grid, type = type))
cat("\nref.grid results:\n")
summary(rg)
}
tst(fm_hnb1)
fix(tst)
tst=edit()
tst(fm_hnb1)
tst(fm_hnb2)
ls()
tst(fm_hp1)
tst(fm_hp2)
summary(fm_hp2)
summary(fm_hnb2)
summary(fm_hnb1)
ls()
fm_hnb1$dist
fm_hnb2$dist
fm_hp1$dist
fm_hp2$dist
tst(fm_hp2)
tst(fm_hnb1)
tst(fm_hnb1,"c")
fix(tst)
tst(fm_hnb1,"c")
tst(fm_hnb1,"z")
tst(fm_hnb1,"p")
tst(fm_hnb2,"m")
tst(fm_hnb2,"c")
tst(fm_hnb2,"z")
tst(fm_hnb2,"p")
tst(fm_hp1,"p")
tst(fm_hp1,"c")
tst(fm_hp1,"r")
tst(fm_hp1,"m")
tst(fm_hp2,"m")
tst(fm_hp2,"c")
tst(fm_hp2,"p")
library(lsmeans)
tst(fm_hp2,"p")
fm_hnb3 = update(fm_hnb1, dist = c("negbin", "geometric"))
?hurdle
fm_hnb3 = update(fm_hnb1, zero.dist = "geometric")
fm_hnb4 = update(fm_hnb1, dist = "geometric")
fm_hnb5 = update(fm_hnb1, dist = "geometric", zero.dist = "geom")
fm_hnb3$dist
fm_hnb4$dist
fm_hnb45dist
fm_hnb5dist
fm_hnb5$dist
tst(fm_hnb3)
tst(fm_hnb3, "c")
tst(fm_hnb3, "p")
tst(fm_hnb4)
tst(fm_hnb4, "c")
library(lsmeans)
tst(fm_hnb4)
tst(fm_hnb4,"c")
tst(fm_hnb4,"p")
tst(fm_hnb3)
tst(fm_hnb3,"c")
tst(fm_hnb3,"p")
tst(fm_hp2,"p")
tst(fm_hp2,"m")
tst(fm_hp2,"c")
tst(fm_hnb5,"c")
tst(fm_hnb5,"p")
tst(fm_hnb5,"m")
TST = function(object) {
print(tst(object, "mean"))
print(tst(object, "count"))
print(tst(object, "prob.ratio"))
}
TST(fm_hnb1)
TST(fm_hnb2)
TST(fm_hp1)
TST(fm_hp2)
TST(fm_hnb3)
TST(fm_hnb4)
TST(fm_hnb5)
fm_hp3 = update(fm_hp1, zero.dist = "negbin")
fm_hp3$dist
TST(fm_hp3)
summary(fm_hp3)
?hurdle
options()
options(help_type = NULL)
?hurdle
options(help_type = "text")
?hurdle
options(help_type = "html")
?hurdle
getwd()
load("h:/downloads/TakeoverBids.rda")
dir("h:/Downloads")
load("h:/Downloads/TakeoverBids.rda")
load("h:/Downloads/TakeoverBids.rda")
load("h:/Downloads/CodParasites.rda")
load("h:/Downloads/DebTrivedi.rda")
install.packages("//home.iowa.uiowa.edu/rlenth/Downloads/countreg_0.1-4.zip", repos = NULL)
install.packages("//home.iowa.uiowa.edu/rlenth/Downloads/countreg_0.1-4.zip", repos = NULL, type="source")
library(countreg)
ls(2)
data(TakeoverBids)
ls()
detach()
names(TakeoverBids)
TB.hnbb = hurdle(bids ~ .|., dist="negbin", zero.dist="bin", data=TakeoverBids)
TB.hnbnb = hurdle(bids ~ .|., dist="negbin", zero.dist="negbin", data=TakeoverBids)
TST(TB.hnbb)
TST(TB.hnbb)
ls()
summary(TB.hnbb)
TB.hnbnb = hurdle(bids ~ whiteknight+bidpremium|realrest, dist="negbin", zero.dist="negbin", data=TakeoverBids)
TB.hnbb = hurdle(bids ~ whiteknight+bidpremium|realrest, dist="negbin", zero.dist="bin", data=TakeoverBids)
TST(TB.hnbb)
tst(TB.hnbb)
tst(TB.hnbnb)
summary(TB.hnbnb)
tst(TB.hnbb,"p")
tst(TB.hnbb,"c")
tst(TB.hnbnb,"p")
tst(TB.hnbnb)
tst(TB.hnbnb,"c")
TB.hnbg = hurdle(bids ~ whiteknight+bidpremium|realrest, dist="negbin", zero.dist="geom", data=TakeoverBids)
tst(TB.hnbg,"m")
tst(TB.hnbg,"p")
coef(TB.hnbg)
coef(TB.hnbnb)
tst(TB.hnbg)
tst(TB.hnbnb)
?D
deriv(~(t/(t+mu))^t, "mu")
dv = .Last.value
with(list(t=1.5, mu=1.8), eval(ev))
with(list(t=1.5, mu=1.8), eval(dv))
with(list(t=1.5, mu=1.8), c((t/(t+mu)^(1+t), eval(dv))
with(list(t=1.5, mu=1.8), c((t/(t+mu)^(1+t), eval(dv))))
with(list(t=1.5, mu=1.8), c((t/(t+mu))^(1+t), eval(dv)))
with(list(t=1.5, mu=1.8), c((t/(t+mu))^(1+t), eval(dv)$mu))
with(list(t=1.5, mu=1.8), c((t/(t+mu))^(1+t), attr(eval(dv), "gradient"))
)
with(list(t=1.5, mu=1.8), c((t/(t+mu))^(1+t), attr(eval(dv), "gradient")))
with(list(t=1.5, mu=2.8), c((t/(t+mu))^(1+t), attr(eval(dv), "gradient")))
with(list(t=.5, mu=2.8), c((t/(t+mu))^(1+t), attr(eval(dv), "gradient")))
ls()
summary(TB.hnbnb)
summary(TB.hnbnp)
summary(TB.hnbp)
summary(TB.hnbg)
tst(TB.hnbp)
tst(TB.hnbg)
tst(TB.hnbnb)
summary(TB.hnbg)
summary(TB.hnbnb)
TB.hnbg = hurdle(bids ~ whiteknight + bidpremium | whiteknight + bidpremium, data = TakeoverBids,
dist = "negbin", zero.dist = "geometric")
summary(TB.hnbg)
tst(TB.hnbg)
TB.hnbg = hurdle(bids ~ whiteknight + bidpremium | whiteknight + bidpremium, data = TakeoverBids,
TB.hnbnb = hurdle(bids ~ whiteknight + bidpremium | whiteknight + bidpremium, data = TakeoverBids,
dist = "negbin", zero.dist = "negbin")
summary(TB.hnbnb)
tst(TB.hnbnb)
tst(TB.hnbnb,"c")
tst(TB.hnbnb,"p")
tst(TB.hnbnb,"z")
tst(TB.hnbg,"z")
summary(TB.hnbg)
tst(HB.hnbg)
tst(TB.hnbg)
tst(TB.hnbg, "c")
tst(TB.hnbg, "p")
tst(TB.hnbg, "z")
TBall.hnbg = hurdle(bids ~ . | ., data = TakeoverBids, dist = "negbin", zero.dist = "geometric")
TBall.hnbnb = hurdle(bids ~ . | ., data = TakeoverBids, dist = "negbin", zero.dist = "negbin")
summary(TBall.hnbg)
summary(TBall.hnbnb)
tst(TBall.hnbnb, "z")
TBall.hnbnb = hurdle(bids ~ . | 1, data = TakeoverBids, dist = "negbin", zero.dist = "negbin")
TBall.hnbnb = hurdle(bids ~ . | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "negbin")
summary(TBall.hnbnb)
tst(TBall.hnbnb, "z")
summary(ref.grid(TBall.hnbnb))
summary(ref.grid(TBall.hnbnb, mode="zero", type = "response"))
TBall.hnbg = hurdle(bids ~ . | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "geometric")
summary(ref.grid(TBall.hnbg, mode="zero", type = "response"))
TBall.hnbg = hurdle(bids ~ realrest | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "geometric")
r.hnbg = hurdle(bids ~ realrest | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "geometric")
r.hnbnb = hurdle(bids ~ realrest | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "negbin")
summary(r.hnbg)
summary(r.hnbnb)
tst(r.hnbg)
tst(r.hnbnb)
q("no")
library(lsmeans)
library(countreg)
help(hurdle)
example(hurdle)
ls()
class(fm_hnb1)
summary(ref.grid(fm_hnb1))
summary(ref.grid(fm_hnb1))
p1
dp1
p2
dp2
mu1
mu2
X2
diag(mu1 * dp2/p1)
mu1 * dp2/p1
diag(.Last.value)
matrix(mu1 * dp2/p1)
diag(1)
diag(.137)
diag(c(.137,.137))
diag(.137)
diag(2)
summary(fm_hnb1)
summary(fm_hnb2)
summary(cs)
summary(ref.grid(fm_hnb1, at=list(width=c(22,26,30),color=1:4)))
summary(ref.grid(fm_hnb2, at=list(width=c(22,26,30),color=1:4)))
data(TakeoverBids)
r.hnbg = hurdle(bids ~ realrest | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "geometric")
r.hnbnb = hurdle(bids ~ realrest | realrest, data = TakeoverBids, dist = "negbin", zero.dist = "negbin")
summary(r.hnbnb)
summary(r.hnbg)
summary(ref.grid(r.hnbg))
summary(ref.grid(r.hnbnb))
summary(r.hnbnb)
summary(fm_hnb2)
q("no")
install.packages("//home.iowa.uiowa.edu/rlenth/Downloads/lsmeans_2.20-31.tar.gz", repos = NULL, type = "source")
library(lsmeans)
vignette("uising-lsmeans")
vignette("using-lsmeans")
q("no")
update.packages()
library()
library(lsmeans)
example(lsmeans)
ls()
slotNames(fiber.lsm)
fiber.lsm@levels
library(lsmeans)
fiber.lsm
fibser.lsm@V
fiber.lsm@V
update(fiber.lsm, V = .5*fiber.lsm@V)
update(fiber.lsm, V = .5*fiber.lsm@V, tran = "log")
update(fiber.lsm, V = .5)
ybar = c(6,7,9,12)
args(lsmobj)
obj = lsmobj(ybar, diag(1, 4), LETTERS[1:4], diag(1, 4), df = 12)
obj
pairs(obj)
pairs(update(obj, V = .9 + diag(.1,4)))
pairs(update(obj, V = -.9 + diag(1.1,4)))
-.9 + diag(1.1,4)
-.9 + diag(1.9,4)
pairs(update(obj, V = -.9 + diag(1.9, 4)))
V1 = matrixc((1,.9,0,0, .9,1,0,0, 0,0,1,.9, 0,0,.9,1), nrow=4)
V1 = matrix(c(1,.9,0,0, .9,1,0,0, 0,0,1,.9, 0,0,.9,1), nrow=4)
V1
pairs(update(obj, V = V1))
pairs(update(obj, V = .9 + diag(.1, 4)))
pairs(update(obj, V = .99 + diag(.01, 4)))
pairs(obj)
pairs(update(obj, V = .999 + diag(.001, 4)))
pairs(update(obj, V = -.999 + diag(1.999, 4)))
fiber.lsm@levels
pairs(update(obj, V = V1, levels = list(subplot=c(1,2),plot=c("A","B"))))
obj@levels
spl = list(subplot=c(1,2), plot=c("A","B"))
pairs(update(obj, V = V1, levels = spl, grid = do.call(expand.grid, spl)))
update(obj, V = V1, levels = spl, grid = do.call(expand.grid, spl))
pairs(update(obj, V = V1, levels = list(level = c("1:a", "1:b", "2:a", "2:b"))))
obj@levels
slotNames(obj)
spobj = update(obj, V = V1, levels = list(level = c("1:a", "1:b", "2:a", "2:b")))
spobj@levels
spobj@grid
spobj = update(obj, V = V1, grid = data.frame(level = c("1:a", "1:b", "2:a", "2:b")))
spobj
pairs*(spobj)
pairs(spobj)
pairs(update(obj, V = .5 + diag(.5, 4)))
csmat = function(corr, k = 4)
corr + diag(1 - corr, k)
csmat(.9)
csmat(.99)
csmat(-.99)
pairs(update(obj, V = csmat(.5))
)
pairs(update(obj, V = csmat(.55)))
pairs(update(obj, V = csmat(.95)))
pairs(update(obj, V = csmat(-.95)))
cld(update(obj, V = csmat(-.95)))
cld(update(obj, V = csmat(.95)))
slotNames(obj)
library(lsmeans)
?update
library(lsmeans)
?models
library(lsmeans)
?update
?summary.ref.grid
q("no")
install.packages("xtable", repos="http://R-Forge.R-project.org")
library(lsmeans)
citation("lsmeans")
q("no")
