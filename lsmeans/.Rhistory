q("no")
install.packages(c("MCMCglmm", "MCMCglmm"))
install.packages("MCMCpack")
install.packages("coda")
library(lsmeans)
load("C:/Lenth/temp/stem.bay1.8c3.Rdata")
ls()
load("C:/Lenth/temp/m1.Rdata")
means1.8c <- lsmeans(stem.bay1.8c, ~ trt * spp, data = m1)
means1.8c <- lsmeans(stem.bay1.8c3, ~ trt * spp, data = m1)
means1.8c
slopes1.8c <- lstrends(stem.bay1.8c3, ~ trt * spp, var = "day", data = m1)
slopes1.8c
head(as.mcmc(slopes1.8c))
head(as.mcmc(slopes1.8c, names=FALSE))
q("no")
library(lsmeans)
?conseq.lsmc
?consec.lsmc
example(lsmeans)
ls()
contrast(warp.lsm, by="wool")
contrast(warp.lsm, "consec", by="wool")
contrast(warp.lsm, "consec", by="wool", rev=TRUE)
contrast(warp.lsm, "mean.chg", by="wool", rev=TRUE)
contrast(warp.lsm, "mean.chg", by=NULL, rev=TRUE)
contrast(warp.lsm, "mean.chg", by=NULL, rev=FALSE)
contrast(warp.lsm, "consec", by=NULL, rev=FALSE)
q("no")
305*1.14
350*1.14
warp.lm = lm(breaks ~ wool*tension, data = warpbreaks)
library(lsmeans)
lsmeans(pairwise ~ tension | wool)
lsmeans(warp.lm, pairwise ~ tension | wool)
comps = pairs(warp.lm, ~ tension | wool)
comps = pairs(lsmeans(warp.lm, ~ tension | wool))
comps
test(comps, by = NULL)
test(comps, by = NULL, adjust = holm)
test(comps, by = NULL, adjust = "holm")
test(comps, adjust = holm)
test(comps, adjust = "holm")
test(comps)
test(comps, by="null")
test(comps, by=NULL)
test(comps, by=NULL, adjust="mvt")
test(comps, adjust="mvt")
test(comps)
fake = comps
fake@misc$fam.size
fake@misc
fake@misc$famSize = 4
test(fake, by=NULL)
q("no")
library(coxme)
library(lsmeans)
fm <- coxme(Surv(y, uncens) ~ trt + (trt | center) + strata(center), data=eortc)
summary(fm)
lsmeans(fm, ~ trt)
class(fm)
library(lsmeans)
ref.grid(fm)
names(object)
object$method = "ML"
names(object)
vcov(object)
ref.grid(fm)
vcov(object)
summary(object)
.07849^2
object$method = "ML"
V
V
object$dims
ref.grid(fm)
object$method = "REML"
library(lsmeans)
lsmeans(fm, "trt")
example(lsmeans)
names(Oats.lme)
Oats.lme$groups
fm$groups
names(fm)
lsmeans(fm, "trt")
lsmeans(fm, "trt")
names(fm)
fm$df
fm$control
fm$n
names(fm)
fm$formulaList
?coxme
library(lsmeans)
example(lsmeans)
ls()
terms(warp.lm)
terms(warp.lm)[-2]
`[.terms`
stats:::`[.terms`
stats:::`[.terms<-`
stats:::`[<-.terms`
trms = terms(warp.lm)
trms[3] = "x"
trms
trms = terms(warp.lm)
trms[1:2]
trms[]
trms[-(1:3)]
attr(trms[-(1:3)], "factors")
class(.Last.value)
dimnames(attr(trms[-(1:3)], "factors"))
pmatch(c("x","y","a"), letters)
q("no")
install.packages("manipulate")
installed.packages()["lsmeans", 1:3]
installed.packages()["lsmeans", ]
penicillin = expand.grid(treat = LETTERS[1:4], blend = factor(1:3))
penicillin$yield = c (
89, 88, 97, 94,
84, 77, NA, 79,
NA, 87, 87, 85)
penicillin.lm = lm(yield ~ treat + blend, data = penicillin)
library(lsmeans)
lsmeans(penicillin.lm, ~ treat * blend)
predict(penicillin.lm, newdata = penicillin)
lsmeans(penicillin.lm, ~ treat)
typing = data.frame(
type = rep(c("A","B","C"), each=4),
hours = c(60,72,61,50, 54,68,66,59, 56,56,55,51),
pain = c(85,95,69,58, 41,74,71,52, 41,34,50,40))
library(lattice)
xyplot(pain ~ hours | type, data = typing, layout = c(3,1))
typing.lm = lm(pain ~ hours + type, data = typing)
lsmeans(typing.lm, list(~ type, ~ type * hours))
# We can use the at argument to override the default reference grid. For example, suppose we want to
# consider hours values of (55, 59, 64):
lsmeans(typing.lm, list(~ type * hours, ~ type, ~ hours),
at = list(hours = c(55,59,64)))
#contrasts andcomparisons
lsmeans(typing.lm, pairwise ~ type)
#
# Note that lsmeans produces two tables for ach two-sided formulaâ€”the first is the LS means, and the second
# is the contrast output.
#2 factor example
with(warpbreaks, table(wool, tension))
warp.lm = lm(breaks ~ wool * tension, data = warpbreaks)
anova(warp.lm)
# The lsmeans package provides a function lsmip that provides an interaction plot based on the LS means:
lsmip(warp.lm, wool ~ tension)
print(lsmeans(warp.lm, list(pairwise ~ wool | tension, poly ~ tension | wool)), omit=3)
lsmeans(warp.lm, ~ wool) ### NOT a good idea!
q("no")
install.packages("lsmeans")
data(Oats, package = "nlme")
aug
nrow(Oats)
aug = function(n = 60) {
added = Oats[sample(1:72, n), ]
added$Block = added$Block + maxb
maxb = maxb + 6
bo <<- rbind(bo, added)
Boats <<- transform(bo, Block = factor(Block))
Boats.lmer <<- lmer(yield ~ Variety + nitro + (1|Block/Variety), data = BOats)
object.size(BOats.lmer)
}
oats = transform(Oats, Block = as.numeric(Block), nitro = factor(nitro))
summary(oats)
maxb = 6
BOats = transform(Oats, nitro = factor(nitro))
fix(aug)
aug()
fix(aug)
no = oats
bo = oats
aug()
library(lme4)
aug()
rm(Boats)
fix(aug)
rm(no)
bo=oats
aug()
rm(Boats.lmer)
lsmeans(BOats.lmer, ~Variety)
library(lsmeans)
lsmeans(BOats.lmer, ~Variety)
packageVersion("lsmeans")
sys.time(lsmeans(BOats.lmer, ~Variety))
??time
??"cpu time"
system.time(lsmeans(BOats.lmer, ~Variety))
aug()
system.time(lsmeans(BOats.lmer, ~Variety))
summary(BOats)
table(BOats$Block)
aug()
aug()
aug()
aug()
system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
maxb
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
lsm.options(pbkrtest.limit = 1e6/2^30)
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
aug(); aug(); aug(); aug(); system.time(lsmeans(BOats.lmer, ~Variety))
system.time(pbkrtest::vcov(BOats.lmer))
system.time(pbkrtest::vcovAdj(BOats.lmer))
library(pbkrtest)
system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); print(system.time(vcovAdj(BOats.lmer)))
aug(); aug(); aug(); aug(); system.time(print(vcovAdj(BOats.lmer)))
fix(aug)
aug(); aug(); aug(); aug(); system.time(print(vcovAdj(BOats.lmer)))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
nrow(BOats)
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
aug(); aug(); aug(); aug(); system.time(vcovAdj(BOats.lmer))
class(BOats.lmer)
str(BOats.lmer)
summary(BOats.lmer)
q("no")
setwd("h:/scratch")
data=read.csv("alligator.csv")
head(data)
library(nnet)
fit=multinom(food~lake+sex+size, data = data)
library(effects)
I now wanted to get pairiwise Tukey posthoc tests between the different lakes using
library(lsmeans)
x=lsmeans(fit, pairwise~lake, adjust="tukey",mode = "prob") x or summary(lsmeans(fit, pairwise~lake, adjust="tukey",mode = "latent"),type="response")
x=lsmeans(fit, pairwise~lake, adjust="tukey",mode = "prob")
x
sessionInfo()
x@misc
x[[1]]@misc
ls()
vcov(fit)
diag(vcov(fit))
x@V
x[[2]]@V
diag(x[[2]]@V)
lsmeans(fit, "lake")
lsmeans(fit, "lake")@V
lsm = lsmeans(fit, "lake")
lsm@linfct %*% lsm@V %*% t(lsm@linfct)
sqrt(diag(.Last.value))
lsm
vcov(lsm)
lsmeans(fit, "sex")
lsmeans(fit, "size")
lsmeans(fit, "food")
lsmeans(fit, "lake", mode = "prop")
lsmeans(fit, "lake", mode = "prob")
lsmeans(fit, ~ response | lake, mode = "prob")
ref.grid(fit, mode = "prob")
ls()
data
with(data, table(sex, lake, size))
with(data, table(sex))
with(data, table(size))
with(data, table(lake))
summary(fit)
class(fit)
ref.grid(fit)
ref.grid(fit, mode = "latent")
lsmeans(fit, "lake, mode = "latent)
lsmeans(fit, "lake", mode = "latent")
lsmeans(fit, c("lake", "sex"), mode = "latent")
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
library(lsmeans)
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
pat
coef(fit)
lsmeans(fit, c("lake", "sex", "size"), mode = "latent")
X
lsmeans(fit, c("lake"), mode = "latent")@linfct
?multinom
pat
lsmeans(fit, c("lake"), mode = "latent")@linfct
lsmeans(fit, c("lake"), mode = "latent")@linfct
pat
pat = pat + .2
pat
library(lsmeans)
lsmeans(fit, c("lake"), mode = "latent")@linfct
pat
lsmeans(fit, c("lake"), mode = "latent")
lsmeans(fit, c("food"))
lsmeans(fit, c("lake"))
lsmeans(fit, c("lake"), mode="latent")
lsmeans(fit, ~ food | lake)
lsmeans(fit, ~ food | lake, mode = "latent")
library(lsmeans)
lsmeans(fit, ~ lake)
lsm.basis.multinom = function(object, trms, xlev, grid,
mode = c("prob", "latent"), ...) {
mode = match.arg(mode)
bhat = t(coef(object))
V = .my.vcov(object, ...)
k = ncol(bhat)
m = model.frame(trms, grid, na.action = na.pass, xlev = xlev)
X = model.matrix(trms, m, contrasts.arg = object$contrasts)
# recenter for latent predictions THIS IS WRONG
pat = (rbind(0, diag(k + 1, k)) - 1) / (k + 1)
# Should not recenter... following is right
# pat = rbind(0, diag(1, k)) # not centered
X = kronecker(pat, X)
nbasis = estimability::all.estble
nbasis = kronecker(rep(1,k), nbasis)
misc = list(tran = "log", inv.lbl = "e^y")
dfargs = list(df = object$edf)
dffun = function(k, dfargs) dfargs$df
ylevs = list(class = object$lev)
if (is.null(ylevs)) ylevs = list(class = seq_len(k))
names(ylevs) = as.character(object$call$formula[[2]])
misc$ylevs = ylevs
if (mode == "prob")
misc$postGridHook = .multinom.postGrid
list(X = X, bhat = as.numeric(bhat), nbasis = nbasis, V = V,
dffun = dffun, dfargs = dfargs, misc = misc)
}
fix(lsm.basis.multinom)
lsmeans(fit, ~ lake)
lsmeans(fit, ~ food | lake)
ls()
lsm.basis.newmult = lsm.basis.multinom
class(fit) = c("newmult", class(multinom))
lsmeans(fit, ~ lake)
recover.data.newmult = lsmeans:::recover.data.multinom
lsmeans(fit, ~ lake)
coef(fit)
class(fit)
class(fit) = c("newmult", "multinom", "nnet")
lsmeans(fit, ~ lake)
fix(lsm.basis.newmult)
lsmeans(fit, ~ lake)
lsm.basis.newmult
lsmeans(fit, ~ lake)
lsmeans(fit, ~ lake, type = "response")
with(data, table(lake))
X = with(data, table(lake, sex, size, food))
X
X = with(data, table(sex, size, food, lake))
XX = matrix(X, ncol=4)
XX
apply(XX, 2, mean)
apply(XX, 2, function(x) exp(mean(log(x+1))) - 1)
apply(XX, 2, function(x) exp(mean(log(x+.1))))
X
q("no")
install.packages("pscl")
library(pscl)
example(zeroinfl)
ls()
summary(fm_zip)
summary(fm_zip2)
summary(bioChemists)
new = with(bioChemists, expand.grid(fem=levels(fem),mar=levels(mar), kid5=mean(kid5),phd=mean(phd),ment=mean(ment)))
new
predict(fm_zip, new=new)
?predict.zeroinfl
predict(fm_zip, new=new,type="r")
predict(fm_zip, new=new,type="p")
predict(fm_zip, new=new,type="r")
predict(fm_zip, new=new,type="c")
predict(fm_zip, new=new,type="z")
(1- 0.1569167)*predict(fm_zip,new=new,type="c")
p=predict(fm_zip2, new=new,type="z")
predict(fm_zip2, new=new,type="c")
(1-p)*.Last.value
predict(fm_zip2, new=new,type="r")
p
model.matrix(fm_zip, model="count", frame=new)
?model.matrix
model.matrix(fm_zip, model="count", data=new)
model.matrix(fm_zip, data=new)
lsmeans:::lsm.basis.lm
terms(fm_zip)
names(fm_zip)
fm_zip$terms
fm_zip$terms$zero
model.matrix(terms(fm_zip, "zero"), data=new)
model.matrix(terms(fm_zip, "count"), data=new)
model.matrix(delete.response(terms(fm_zip, "count")), data=new)
model.matrix(terms(fm_zip2, "zero"), data=new)
coef(fm_zip)
coef(fm_zip2)
coef(fm_zip2,"count")
coef(fm_zip2,"zero")
coef(fm_zip2,"both")
coef(fm_zip2,"full")
fm_zip$coefficients
q("no")
