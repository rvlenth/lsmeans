seiz.l$t <- ifelse(seiz.l$time == 0, 8, 2)
seiz.l$x <- ifelse(seiz.l$time == 0, 0, 1)
m1 <- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
data=seiz.l, corstr="exch", family=poisson)
data(seizure)
## Diggle, Liang, and Zeger (1994) pp166-168, compare Table 8.10
seiz.l <- reshape(seizure,
varying=list(c("base","y1", "y2", "y3", "y4")),
v.names="y", times=0:4, direction="long")
seiz.l <- seiz.l[order(seiz.l$id, seiz.l$time),]
seiz.l$t <- ifelse(seiz.l$time == 0, 8, 2)
seiz.l$x <- ifelse(seiz.l$time == 0, 0, 1)
m1 <- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
data=seiz.l, corstr="exch", family=poisson)
summary(m1)
names(m1)
class(v1)
class(m1)
names(seiz.1)
names(seiz.l)
summary(seiz.l$trt)
ref.grid(m1, at=list(trt=c(0,1)))
terms(m1)
terms(gee1)
ref.grid(gee1)
library(lsmeans)
ref.grid(gee1)
library(lsmeans)
ref.grid(gee1)
lsmeans(gee1, "Cu")
ref.grid(gee1)@betahat
ref.grid(gee1)@bhat
ref.grid(gee1)@V
fm
lsmeans(fm, "OME")
library(lsmeans)
lsmeans(fm, "OME")
lsmeans(fm, "OME", vcov="naive")
lsmeans(fm, "OME", vcov="naive")
lsmeans(fm, "OME", vcov.method="naive")
library(lsmeans)
lsmeans(fm, "OME", vcov.method="naive")
names(m1)
m1$model
m1$formula
m1$call
m1$control
eval(m1$call)
m1$call$family
terms(m1$call)
attributes(m1)
m1$call$family$family
print.default(m1$call$family)
class(m1$call$family)
eval(m1$call$family)
eval(m1$call$family)$link
eval(m1$call$family)()$link
lsmeans(gee1, "trt", at=list(trt=c(0,1)))
ref.grid(gee1)
coef(gee1)
coef(fm)
library(lsmeans)
library(lsmeans)
lsmeans(gee1, "Cu")
ref.grid(gee1)
coef(gee1)
class(.Last.value)
library(lsmeans)
ref.grid(gee1)
predict(.Last.value)
ref.grid(gee1)@bhat
library(lsmeans)
ref.grid(gee1)
coef(gee1)
class(gee1)
coef.geeglm
geepack:::coef.geeglm
class(gee1)
coef.gee(gee1)
gee:::coef.gee(gee1)
stats:::coef.glm(gee1)
stats:::coef.lm(gee1)
methods("coef")
stats:::coef.default(gee1)
coef.default(gee1)
stats::coef.default(gee1)
names(fm)
stats::coef.default
stats:::coef.default
gee1$coefficients
names(gee1$geese)
coef(gee1$geese)
gee1$geese$beta
gee1$geese$call
geepack:::geeglm
names(gee1)
terms(model.frame(y~x))
y=1:20
x=y
terms(model.frame(y~x))
cl = gee1$geese$call
cl[[1]]
cl[[1]] = "model.frame"
terms(eval(cl))
cl[[1]] = model.frame
terms(eval(cl))
cl$family=NULL
terms(eval(cl))
cl$corstr=NULL
terms(eval(cl))
cl = gee1$geese$call
names(cl)
as.list(cl[c("formula","data","subset","na.action")])
args = as.list(cl[c("formula","data","subset","na.action")])
do.call("model.frame", args)
do.call("terms", args)
?terms
do.call("terms.formula", args)
args$mf
ls()
class(m1)
m1$call
gee1$geese$call
gee1$qr
gee1$family
names(m1)
methods("terms")
terms.formula
terms(y~x)
args = as.list(m1$call[-1])
args
terms.formula(x=args$formula, data=args$data)
terms.formula(x=args$formula)
parent.frame()
recover.data(m1$call, terms(m1$call$formula)), data = NULL)
recover.data(m1$call, terms(m1$call$formula), data = NULL)
recover.data(m1$call, terms(as.list(m1$call$formula)), data = NULL)
m1$call$formula
terms(m1$call$formula)
recover.data(m1$call, terms.formula(m1$call$formula)), data = NULL)
recover.data(m1$call, terms.formula(m1$call$formula), data = NULL)
recover.data(m1$call, terms.formula(m1$call$formula), na.action = na.omit, data = NULL)
na.omit
recover.data(m1$call, terms.formula(m1$call$formula), na.action = NULL, data = NULL)
m1$qr
m1$call$family
eval(m1$call$family)()
library(lsmeans)
library(lsmeans)
ref.grid(m1)
ref.grid(gee1)
lsmeans(gee1, "Cu")
lsmeans(gee1, "Cu", vcov = "naive")
m1$call
?offset
terms.formula(m1$call$formula)
terms.formula(m1$call$formula, data = seiz.l)
terms(model.frame(m1$call$formula, data = seiz.l))
terms.formula(m1$call$formula, data = NULL)
terms(model.frame(m1$call$formula, data =NULL))
library(lsmeans)
ref.grid(m1)
lsmeans(m1, "trt", at = list(trt=c(0,1)))
lsmeans(m1, "trt", at = list(trt=c(0,1)), vcov="naive")
names(m1)
lsmeans(m1, "trt", at = list(trt=c(0,1)), vcov="vbeta.na")
lsmeans(m1, "trt", at = list(trt=c(0,1)), vcov="vbeta.ajs")
lsmeans(m1, "trt", at = list(trt=c(0,1)), vcov="vbeta.j1s")
m1l = lsmeans(m1, "trt", at = list(trt=c(0,1)))
summary(m1l, type="r")
m1$call
summary(seiz.l)
uniquye(seiz.l$t)
unique(seiz.l$t)
m1l = lsmeans(m1, c("trt","x"), at = list(trt=c(0,1), x=c(0,1)))
m1l
lsmip(m1l, x~trt)
lsmip(m1l, x~trt, type="r")
m1l = lsmeans(m1, c("trt","x", "t"), at = list(trt=c(0,1), x=c(0,1), t=c(2,8)))
m1l
lsmip(m1l, x~trt|t, type="r")
lsmip(m1l, x~trt|t)
pairs(m1l, by=c("x","t"))
pairs(m1l, by=c("x","trt"))
m1l = lsmeans(m1, c("trt","x", "t"), at = list(trt=c(0,1), x=c(0,1), t=2))
pairs(m1l, by="x")
pairs(m1l, by="trt")
q("no")
data = read.csv("h:/Downloads/data.csv")
head(data)
pt1 = c(.29,90); pt2=c(.38,30)
(b = (pt1[2] - pt2[2])/(pt1[1]-pt2[1]))
(a=pt1[2] - b*pt1[1])
plot(Y~X, data=data)
abline(a,b)
data = transform(data, fit = a + b*X)
data = transform(data, resid = Y - fit)
data = transform(data, resid = Y - fit, col = 1 + (Y>62))
plot(resid ~ fit, data = data, col=col)
abline(h=0, lty=2)
abline(v=0, lty=2)
q("no")
installed.packages()["lsmeans",1:3]
install.packages("lsmeans")
install.packages(c("BH", "caTools", "coin", "devtools", "doBy", "e1071", "Ecdat", "geepack", "gplots", "Hmisc", "htmltools", "httr", "jsonlite", "party", "pbkrtest", "prodlim", "R2HTML", "Rcmdr", "RcmdrMisc", "rgl", "RUnit", "segmented", "xtable"))
methods("recover.data")
install.packages(c("RVAideMemoire", "ordinal"))
library(RVAideMemoire)
methods("recover.data")
library(lsmeans)
methods("recover.data")
args(get)
q("no")
library(ordinal)
?clm
q("no")
library(ordinal)
example(clm)
ls()
?clm
fm2
confint(fm1)
fm1
library(lsmeans)
ref.grid(fm1)
fm1 <- clm(rating ~ temp * contact, data = wine)
ref.grid(fm1)
names(wine)
lsmeans(fm1, ~contact:temp|cut)
confint(fm1)
plot(profile(fm1))
par(mfrow=c(1,1))
plot(profile(fm1))
par(ask=FALSE)
fmc = update(fm1, link="cauchit")
plot(profile(fmc))
summary(lsmeans(fmc, ~temp:contact|cut))
summary(lsmeans(fmc, ~temp:contact|cut), type="r")
fm1
summary(lsmeans(fm1, ~temp:contact|cut), type="r")
lsmip(fm1, temp~contact|cut)
lsmip(fmc, temp~contact|cut)
lsmip(fm1, temp~contact|cut, type="r")
lsmip(fmc, temp~contact|cut, type="r")
fm4 = update(fm1, thresh="eq")
lsmip(fm4, temp~contact|cut, type="r")
lsmip(fm1, temp~contact|cut, type="r")
?wine
lsmeans(fm1, ~temp:contact)
lsmeans(fm4, ~temp:contact)
summary(lsmeans(fm4, ~temp:contact), type="r")
summary(lsmeans(fm4, ~temp:contact|cut), type="r")
with(wine, table(bottle,judge))
with(wine, table(bottle,temp))
with(wine, table(bottle,temp,contact))
fm.soup
lsmeans(fm.soup, ~PRODID|cut)
lsmeans(fm.soup, ~PRODID)
cld(lsmeans(fm.soup, ~PRODID|cut))
pairs(lsmeans(fm.soup, ~PRODID|cut))
pairs(lsmeans(fm.soup, ~PRODID))
cld(lsmeans(fm.soup, ~PRODID))
cld(lsmeans(fm.soup, ~PRODID, at=list(cut="3|4")))
summary(fm.soup)
pairs(lsmeans(fm.soup, ~PRODID))
anova(fm1,fmc)
anova(fm1,fm6)
anova(fm1,fm5)
slice(fm1)
slice.fm1 <- slice(fm1)
par(mfrow = c(3, 3))
plot(slice.fm1)
?clmm
mm1 <- clmm(SURENESS ~ PROD + (1|RESP) + (1|RESP:PROD), data = soup,
link = "probit", threshold = "equidistant")
mm1nh <- clmm(SURENESS ~ PROD + (1|RESP) + (1|RESP:PROD), data = soup,
link = "probit", threshold = "equidistant", Hess=FALSE)
mm1nh$Hessian
mm1$Hessian
vcov(mm1nh)
mm1nhu = update(mm1nh, Hess=TRUE)
vcov(mm1nhu)
mm1nhu$Hessian
mm1$gfList
names(mm1$gfList)
class(mm1$Hessian)
vcov(mm1)
library(lsmeans)
rg = ref.grid(mm1nh)
rg = ref.grid(mm1)
View(tJac)
mm1$tJac
m1$tJac
ls()
fm1$tJac
mm2 = update(mm1, thresh="equi")
mm2 = update(mm1, threshold="equi")
mm2$tJac
mm2$threshold
fm1$df.residual
mm1$df.residual
fm6$tJac
summary(mm1)
mm1
mm1$threshold
mmf = clmm(SURENESS ~ PROD + (1|RESP) + (1|RESP:PROD), data = soup,
link = "probit", threshold = "flexible")
mmf$tJac
rownames(mmf$tJac)
ref.grid(mmf)
library(lsmeans)
ref.grid(mmf)
lsmeans(mmf, ~PROF|cut)
D
lsmeans(mmf, ~PROD|cut)
lsmeans(mm1, ~PROD|cut)
library(lsmeans)
lsmeans(mm1, ~PROD|cut)
lsmeans(mm1, ~PROD|cut)
result$V
library(lsmeans)
lsmeans(mm1, ~PROD|cut)
lsmeans(mm1, ~PROD|cut)
V
V
V
dimnames(V) <- list(c(cnm,bnm),c(cnm,bnm))
V
result$V
library(lsmeans)
lsmeans(mm1, ~PROD|cut)
pm1 = clm(SURENESS ~ PROD, data=soup, thresh="equi")
lsmeans(pm1, ~PROD|cut)
lsmeans(pm1, ~PROD)
lsmeans(mm1, ~PROD)
summary(pm1)
pm1$df.residual
lsmeans(mmf, ~PROD, mult.name="threshold")
lsmeans(mmf, ~PROD|threshold, mult.name="threshold")
names(wine)
wine.clm = clm(rating ~ judge + temp*contact, data = wine)
wine.clmm = clmm(rating ~ temp*contact + (1|judge), data = wine)
lsmeans(wine.clm, ~temp*contact)
lsmeans(wine.clmm, ~temp*contact)
lsmeans(wine.clmm, ~temp*contact, at = list(cut="2|3"))
lsmeans(wine.clm, ~temp*contact, at = list(cut="2|3"))
pairs(lsmeans(wine.clm, ~temp*contact, at = list(cut="2|3")))
pairs(lsmeans(wine.clmm, ~temp*contact, at = list(cut="2|3")))
pairs(lsmeans(wine.clmm, ~temp|contact, at = list(cut="2|3")))
pairs(lsmeans(wine.clm, ~temp|contact, at = list(cut="2|3")))
pairs(lsmeans(wine.clm, ~contact|temp, at = list(cut="2|3")))
pairs(lsmeans(wine.clmm, ~contact|temp, at = list(cut="2|3")))
anova(wine.clm)
anova(wine.clm, wine.clmm)
summary(wine.clm)
summary(wine.clmm)
vcov(wine.clm)
vcov(wine.clmm)
predict(wine.clm, type="r")
predict(wine.clm, type="cum.prob")
wine.rg = ref.grid(wine.clmm)
wine.rg
predict(wine.clmm, newdata=wine.rg@grid[1:4, ])
predict(wine.clm, newdata=wine.rg@grid[1:4, ])
wine.rg = ref.grid(wine.clm)
predict(wine.clm, newdata=wine.rg@grid[1:32, ])
wine.rg
predict(wine.clm, newdata=wine.rg@grid[1:36, ])
matrix(predict(wine.rg, ncol=5))
P = matrix(predict(wine.rg), ncol=5)
144/36
P = matrix(predict(wine.rg), ncol=4)
P
predict(wine.clm, newdata=wine.rg@grid[1:36, ])
CP = predict(wine.clm, newdata=wine.rg@grid[1:36, ])
CPP = t(apply(CP, 1 function(x) x=cumsum(x)[-5]; logit(x)))
CPP = t(apply(CP, 1 function(x) {x=cumsum(x)[-5]; logit(x)}))
CPP = t(apply(CP, 1, function(x) {x=cumsum(x)[-5]; logit(x)}))
CP
apply(CP, 1, function(x) {x=cumsum(x)[-5]; logit(x)})
apply(CP, 1, function(x) {cumsum(x)[-5]})
apply(CP, 1, cumsum)
class(CP)
apply(as.matrix(CP), 1, function(x) {x=cumsum(x)[-5]; logit(x)})
as.matrix(CP)
apply(CP[[1]], 1, function(x) {x=cumsum(x)[-5]; logit(x)})
logit = function(p) log(p/(1-p))
apply(CP[[1]], 1, function(x) {x=cumsum(x)[-5]; logit(x)})
CPP = t(apply(CP[[1]], 1, function(x) {x=cumsum(x)[-5]; logit(x)}))
CPP
head(CPP)
head(P)
args(pmatch)
alt.opts = c("left","both","right","two-sided","noninferiority","nonsuperiority","equivalence","lcl","ucl")
pmatch(NA, alt.opts, 3)
pmatch(mean, alt.opts, 3)
pmatch(17, alt.opts, 3)
pmatch(matrix(5,nrow=2), alt.opts, 3)
alt.opts = c(alt.opts, "2")
pmatch(2, alt.opts, 3)
alt.opts = c(alt.opts, c("-1","1","+1"))
pmatch(-1, alt.opts, 3)
pmatch(1, alt.opts, 3)
pmatch("+", alt.opts, 3)
pmatch("-", alt.opts, 3)
pmatch(5, alt.opts, 3)
pmatch(5, alt.opts, 2)
sign(0)
sign(-3)
library(lsmeans)
example(lsmeans)
ls()
Oats.lme
lsmeans(Oats.lme, "Variety")
test(lsmeans(Oats.lme, "Variety"))
test(lsmeans(Oats.lme, "Variety"), alt=c(100,100,90))
test(lsmeans(Oats.lme, "Variety"), alt=100
)
test(lsmeans(Oats.lme, "Variety"), alt=100, side=1)
test(lsmeans(Oats.lme, "Variety"), alt=100, side=-1)
library(lsmeans)
test(lsmeans(Oats.lme, "Variety"), alt=100, side=-1)
test(lsmeans(Oats.lme, "Variety"), alt=100, side=1)
test(lsmeans(Oats.lme, "Variety"), alt=100, side=1, delta = 3)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta = 10)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta = 20)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta = 20)
library(lsmeans)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta = 20)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta = 0)
pnorm(-1.132)
test(lsmeans(Oats.lme, "Variety"), alt=100, side="right")
test(lsmeans(Oats.lme, "Variety"), alt=100, side="-")
library(lsmeans)
test(lsmeans(Oats.lme, "Variety"), alt=100, side="-")
library(lsmeans)
test(lsmeans(Oats.lme, "Variety"), alt=100, side="-")
test(lsmeans(Oats.lme, "Variety"), alt=100)
summary(lsmeans(Oats.lme, "Variety"), infer=TRUE, alt=100)
summary(lsmeans(Oats.lme, "Variety"), infer=TRUE, alt=c(90,100))
summary(lsmeans(Oats.lme, "Variety"), infer=TRUE, alt=c(90,100,95))
summary(lsmeans(Oats.lme, "Variety"), infer=TRUE, alt=c(90,100,95), side="+")
test(lsmeans(Oats.lme, "Variety"), alt=100, delta=20)
test(lsmeans(Oats.lme, "Variety"), alt=100, delta=20, side="noni")
args(summary)
args(summary.ref.grid)
args(lsmeans:::summary.ref.grid)
ls()
alt.opts
q("no")
library(ordinal)
names(wine)
wines.clm = clm(rating ~ temp, scale = ~contact, data = wine)
coef(wines.clm)
wines.clm = clm(rating ~ temp*contact, scale = ~contact, data = wine)
coef(wines.clm)
coef(wines.clm)["contactyes"]
library(lsmeans)
vcov(wines.clm)
ref.grid(wines.clm)
ref.grid(clm(rating~temp, scale=~contact, data=wine))
wines.clm$beta
wines.clm$zeta
names(wines.clm)
?model.matrix
library(lsmeans)
ref.grid(wines.clm)
library(lsmeans)
ref.grid(wines.clm)
View(S)
ref.grid(wines.clm)
View(m)
View(grid)
View(X)
object
ref.grid(wines.clm)
ref.grid(wines.clm)
View(X)
bhat
RD=lsmeans:::recover.data.clm(wines.clm)
RD=lsmeans:::recover.data.clm(wines.clm, data=NULL)
RD
attributes(RD)
library(lsmeans)
RD=lsmeans:::recover.data.clm(wines.clm, data=NULL)
library(lsmeans)
ref.grid(wines.clm)
library(lsmeans)
ref.grid(wines.clm)
ref.grid(wines.clm)
X
S
m
grid
ref.grid(clm(rating~temp, scale=~contact, data=wine))
wines1.clm = clm(rating~temp, scale=~contact, data=wine)
ref.grid(wines.clm)
ref.grid(wines1.clm)
library(lsmeans)
ref.grid(wines1.clm)
library(lsmeans)
ref.grid(wines1.clm)
library(lsmeans)
ref.grid(wines1.clm)
library(lsmeans)
library(lsmeans)
ref.grid(wines1.clm)
X
S
ref.grid(wines.clm)
X
S
